---
title: Certificate Authority Core Concepts
html_title: Certificate authority core concepts for open source step-ca
description: Learn about certificate authority core concepts for open source step-ca
unfurl: /static/graphics/smallstep-docs-unfurl.png
---

import CodeBlock from 'docs/CodeBlock';

This document defines and describes certificate authority core concepts that are integral to the design
and practical usage of `step-ca`.

## Before You Begin

* If you're unfamiliar with public key infrastructure (PKI) and the world of certificate management, start with our blog post [Everything PKI](https://smallstep.com/blog/everything-pki/).
* Why should I use TLS certificates and mutual TLS? Read [the case for using TLS everywhere](https://smallstep.com/blog/use-tls/)
* What are SSH certificates and how do they compare with public keys? Read [If you’re not using SSH certificates you’re doing SSH wrong](https://smallstep.com/blog/use-ssh-certificates/)

## Overview

- [Online vs. Offline Modes (X.509/TLS Only)](#online-vs-offline-modes-x509-tls-only)
- [Provisioners](#provisioners)
- [Active vs. Passive Revocation](#active-vs-passive-revocation)

## Online vs. Offline Modes (X.509/TLS Only)

Our tools support three modes of generating and operating a Certificate Authority (CA):
* Online: An online database-backed CA, running the `step-ca` server and `step ca` client subcommand.
* Local: A local (or airgapped) database-backed CA, using the `step ca` subcommand with `--offline`.
* Offline: A minimalist, offline, stateless CA, using the `step certificate` subcommand
  ([docs here][stateless-ca]).

![](../../../static/images/cas-three-ways.png)

When referring to CAs, _offline_ generally means air-gapped or network isolated.
However, the term _offline_ has a different meaning in the context of `step-ca`.
When the `step-ca` daemon is running, it is responding to network requests.
But `step-ca` can also operate "offline", without the `step-ca` server, by accessing the signing keys locally.
We call this static, non-daemonized operation _offline mode_.
Any further use of the term _offline_ in these docs will refer to _offline mode_ in the context of `step-ca` (local access only).

[stateless-ca]: /docs/step-cli/basic-crypto-operations#run-an-offline-x509-certificate-authority
[stateful-ca]: /docs/step-ca/getting-started

## Provisioners

The certificate signing API exposed by `step-ca` requires mutual
authentication. The CA authenticates to the client using a certificate (which
the client verifies using the root certificate created during CA initialization). 
But the client must also authenticate to the CA. Again, this
presents a challenge: the client obviously can't use a certificate for
authentication because it doesn't have one yet.

To verify the legitimacy of certificate signing requests, we need some entity
that the CA trusts to measure and attest to the identity of our workloads. In
the _step certificates_ architecture this entity is called a _provisioner_,
because it helps to provision certificates.

In general, once a _provisioner_ authenticates a workload's identity it issues
the workload a _bearer token_ to submit to the CA, along with a [certificate
signing
request](https://smallstep.com/blog/everything-pki.html#certificate-signing-requests
'CSR') (CSR), to obtain a certificate. The _bearer token_ authenticates the
workload and authorizes the certificate request.

![Generic Architecture](https://i.imgur.com/zH4RYEj.png 'Generic Architecture')

The details of how a provisioner interacts with a workload (or device or
person) and the CA vary by provisioner type. Smallstep supports a number of
provisioner types including:

- [ACME protocol](/docs/step-ca/configuration#acme)
- [OAuth/OIDC Single Sign-on](/docs/step-ca/configuration#oauthoidc-single-sign-on)
- [AWS Instance Identity Documents](/docs/step-ca/configuration#aws)
- [Google Cloud Instance Identity Tokens](/docs/step-ca/configuration#gcp)
- [Azure Instance Metadata Service](/docs/step-ca/configuration#azure) 
- [Kubernetes Service Account Tokens](/docs/step-ca/configuration#k8ssa-kubernetes-service-account) 
- [JWT for building custom integrations](/docs/step-ca/configuration#jwt)

## Active vs. passive revocation

On the public internet, sometimes HTTPS certificates need to be revoked before
they expire. Over the years, there have been several methods for _actively
revoking_ HTTPS certificates. Any approach to solving this problem adds
complexity to the PKI—usually in the form of additional network requests. For
example, a web browser might need to fetch a Certificate Revocation List (CRL)
from a URL embedded in an HTTPS certificate so it can make sure the
certificate, which would otherwise be valid, has not been actively revoked by
a trusted authority.

When designing a private PKI, you can make things a lot simpler and more
decentralized. If you make certificate lifetimes short enough, you can
_passively revoke_ a certificate by letting it expire and making sure the
Certificate Authority knows to reject any attempts to renew it.

![passive revocation diagram](../../../static/images/passive-revocation.png)

## Next Steps

- Read the [Getting Started](/docs/step-ca/getting-started) to set up a CA and get your first certificate.
- Read the [Getting Started with SSH](/docs/step-ca/ssh-getting-started) to set up an SSH CA.
